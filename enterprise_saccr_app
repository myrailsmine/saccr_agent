# ==============================================================================
# Enhanced AI-Powered SA-CCR Platform with Structured Output Format
#
# This script creates a complete SA-CCR application with structured bullet-point
# output format, comprehensive input validation, and detailed counterparty information.
#
# To Run:
# 1. Install dependencies: pip install streamlit pandas plotly langchain langchain-openai
# 2. Save this file as `enhanced_saccr_app.py`
# 3. Run from terminal: streamlit run enhanced_saccr_app.py
# ==============================================================================

import streamlit as st
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta
import json
from dataclasses import dataclass
from typing import Dict, List, Optional
from enum import Enum
import math
import re

# LangChain imports for LLM integration
from langchain_openai import ChatOpenAI
from langchain.schema import HumanMessage, SystemMessage

# ==============================================================================
# ENHANCED UI CONFIGURATION
# ==============================================================================

st.set_page_config(
    page_title="Enhanced SA-CCR Platform",
    page_icon="🧮",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Enhanced CSS for professional styling
st.markdown("""
<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
    
    .main { font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; }
    
    .structured-header {
        background: linear-gradient(135deg, #2E86AB 0%, #A23B72 100%);
        color: white;
        padding: 2rem;
        border-radius: 12px;
        margin-bottom: 1.5rem;
        box-shadow: 0 8px 32px rgba(0,0,0,0.1);
    }
    
    .section-header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 1rem;
        border-radius: 8px;
        margin: 1rem 0;
        font-weight: 600;
        font-size: 1.1rem;
    }
    
    .given-inputs {
        background: #f8f9ff;
        border-left: 4px solid #4CAF50;
        padding: 1.5rem;
        margin: 1rem 0;
        border-radius: 8px;
    }
    
    .collateral-info {
        background: #fff8e1;
        border-left: 4px solid #FF9800;
        padding: 1.5rem;
        margin: 1rem 0;
        border-radius: 8px;
    }
    
    .calculation-step {
        background: #ffffff;
        border: 1px solid #e1e5e9;
        padding: 1.5rem;
        margin: 0.5rem 0;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    
    .step-title {
        font-size: 1.2rem;
        font-weight: 600;
        color: #1976d2;
        margin-bottom: 0.5rem;
    }
    
    .formula-box {
        background: #f5f5f5;
        padding: 1rem;
        border-radius: 6px;
        font-family: 'Monaco', 'Menlo', monospace;
        border-left: 3px solid #2196F3;
        margin: 0.5rem 0;
    }
    
    .result-highlight {
        background: #e8f5e8;
        padding: 0.8rem;
        border-radius: 6px;
        font-weight: 600;
        color: #2e7d32;
        margin: 0.5rem 0;
    }
    
    .final-result {
        background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
        color: white;
        padding: 1.5rem;
        border-radius: 12px;
        margin: 1rem 0;
        text-align: center;
        font-size: 1.3rem;
        font-weight: 700;
        box-shadow: 0 4px 16px rgba(76, 175, 80, 0.3);
    }
    
    .missing-info {
        background: #ffebee;
        border-left: 4px solid #f44336;
        padding: 1rem;
        margin: 1rem 0;
        border-radius: 8px;
    }
    
    .counterparty-details {
        background: #e3f2fd;
        border-left: 4px solid #2196F3;
        padding: 1.5rem;
        margin: 1rem 0;
        border-radius: 8px;
    }
</style>
""", unsafe_allow_html=True)

# ==============================================================================
# ENHANCED DATA CLASSES
# ==============================================================================

class AssetClass(Enum):
    INTEREST_RATE = "Interest Rate"
    FOREIGN_EXCHANGE = "Foreign Exchange"
    CREDIT = "Credit"
    EQUITY = "Equity"
    COMMODITY = "Commodity"

class TradeType(Enum):
    SWAP = "Swap"
    FORWARD = "Forward"
    OPTION = "Option"
    SWAPTION = "Swaption"

class CollateralType(Enum):
    CASH = "Cash"
    GOVERNMENT_BONDS = "Government Bonds"
    CORPORATE_BONDS = "Corporate Bonds"
    EQUITIES = "Equities"
    MONEY_MARKET = "Money Market Funds"

class CounterpartyType(Enum):
    CORPORATE = "Corporate"
    BANK = "Bank"
    SOVEREIGN = "Sovereign"
    RETAIL = "Retail"
    OTHER_FINANCIAL = "Other Financial Institution"

@dataclass
class CounterpartyInfo:
    name: str
    country: str = ""
    legal_code: str = ""
    legal_code_description: str = ""
    counterparty_type: CounterpartyType = CounterpartyType.CORPORATE
    credit_rating: str = ""
    b3s_risk_weight_category: str = ""
    b3s_risk_weight: float = 1.0

@dataclass
class Trade:
    trade_id: str
    counterparty: str
    asset_class: AssetClass
    trade_type: TradeType
    notional: float
    currency: str
    underlying: str
    maturity_date: datetime
    mtm_value: float = 0.0
    delta: float = 1.0
    basis_flag: bool = False
    volatility_flag: bool = False
    ceu_flag: int = 1

    def time_to_maturity(self) -> float:
        return max(0, (self.maturity_date - datetime.now()).days / 365.25)

@dataclass
class NettingSet:
    netting_set_id: str
    counterparty_info: CounterpartyInfo
    trades: List[Trade]
    threshold: Optional[float] = None
    mta: Optional[float] = None
    nica: float = 0.0
    is_margined: bool = False

@dataclass
class Collateral:
    collateral_type: CollateralType
    currency: str
    amount: float
    market_value: float = None
    haircut_percentage: float = None

    def __post_init__(self):
        if self.market_value is None:
            self.market_value = self.amount
        if self.haircut_percentage is None:
            self.haircut_percentage = self._get_default_haircut()

    def _get_default_haircut(self) -> float:
        haircut_mapping = {
            CollateralType.CASH: 0.0,
            CollateralType.GOVERNMENT_BONDS: 0.5,
            CollateralType.CORPORATE_BONDS: 4.0,
            CollateralType.EQUITIES: 15.0,
            CollateralType.MONEY_MARKET: 0.5
        }
        return haircut_mapping.get(self.collateral_type, 15.0)

# ==============================================================================
# ENHANCED SA-CCR AGENT WITH STRUCTURED OUTPUT
# ==============================================================================

class EnhancedSACCRAgent:
    """Enhanced SA-CCR Agent with structured bullet-point output format"""

    def __init__(self):
        self.llm = None
        self.connection_status = "disconnected"
        self.supervisory_factors = self._initialize_supervisory_factors()
        self.supervisory_correlations = self._initialize_correlations()
        self.collateral_haircuts = self._initialize_collateral_haircuts()
        self.risk_weight_mapping = self._initialize_risk_weight_mapping()

    def setup_llm_connection(self, config: Dict) -> bool:
        """Setup LangChain ChatOpenAI connection"""
        try:
            self.llm = ChatOpenAI(
                base_url=config.get('base_url', "http://localhost:8123/v1"),
                api_key=config.get('api_key', "not-needed"),
                model=config.get('model', "llama3"),
                temperature=config.get('temperature', 0.3),
                max_tokens=config.get('max_tokens', 4000),
                streaming=config.get('streaming', False)
            )
            
            test_response = self.llm.invoke([
                SystemMessage(content="You are a helpful assistant. Respond with 'Connected' if you receive this."),
                HumanMessage(content="Test")
            ])
            
            if "Connected" in test_response.content:
                self.connection_status = "connected"
                return True
            else:
                self.connection_status = "disconnected"
                return False
                
        except Exception as e:
            st.error(f"LLM Connection Error: {str(e)}")
            self.connection_status = "disconnected"
            return False

    def _initialize_supervisory_factors(self) -> Dict:
        return {
            AssetClass.INTEREST_RATE: {
                'USD': {'<2y': 0.50, '2-5y': 0.50, '>5y': 1.50},
                'EUR': {'<2y': 0.50, '2-5y': 0.50, '>5y': 1.50},
                'JPY': {'<2y': 0.50, '2-5y': 0.50, '>5y': 1.50},
                'GBP': {'<2y': 0.50, '2-5y': 0.50, '>5y': 1.50},
                'other': {'<2y': 1.50, '2-5y': 1.50, '>5y': 1.50}
            },
            AssetClass.FOREIGN_EXCHANGE: {'G10': 4.0, 'emerging': 15.0},
            AssetClass.CREDIT: {'IG_single': 0.46, 'HY_single': 1.30},
            AssetClass.EQUITY: {'single_large': 32.0, 'single_small': 40.0},
            AssetClass.COMMODITY: {'energy': 18.0}
        }

    def _initialize_correlations(self) -> Dict:
        return {
            AssetClass.INTEREST_RATE: 0.99,
            AssetClass.FOREIGN_EXCHANGE: 0.60,
            AssetClass.CREDIT: 0.50,
            AssetClass.EQUITY: 0.80,
            AssetClass.COMMODITY: 0.40
        }

    def _initialize_collateral_haircuts(self) -> Dict:
        return {
            CollateralType.CASH: 0.0,
            CollateralType.GOVERNMENT_BONDS: 0.5,
            CollateralType.CORPORATE_BONDS: 4.0,
            CollateralType.EQUITIES: 15.0,
            CollateralType.MONEY_MARKET: 0.5
        }

    def _initialize_risk_weight_mapping(self) -> Dict:
        return {
            CounterpartyType.CORPORATE: {'risk_weight': 1.0, 'category': 'Corporate Exposure'},
            CounterpartyType.BANK: {'risk_weight': 0.20, 'category': 'Bank Exposure'},
            CounterpartyType.SOVEREIGN: {'risk_weight': 0.0, 'category': 'Sovereign Exposure'},
            CounterpartyType.RETAIL: {'risk_weight': 0.75, 'category': 'Retail Exposure'},
            CounterpartyType.OTHER_FINANCIAL: {'risk_weight': 1.25, 'category': 'Other Financial Institution'}
        }

    def validate_input_completeness(self, netting_set: NettingSet, collateral: List[Collateral] = None) -> Dict:
        """Comprehensive input validation with specific missing field identification"""
        missing_fields = []
        warnings = []
        
        # Netting Set Validation
        if not netting_set.netting_set_id:
            missing_fields.append("**Netting Set ID** - Required for identification")
        
        # Counterparty Information Validation
        if not netting_set.counterparty_info.name:
            missing_fields.append("**Counterparty Name** - Required for calculation")
        if not netting_set.counterparty_info.country:
            missing_fields.append("**Counterparty Country** - Required for regulatory classification")
        if not netting_set.counterparty_info.legal_code:
            missing_fields.append("**Legal Entity Code** - Required for risk weight determination")
        if not netting_set.counterparty_info.legal_code_description:
            missing_fields.append("**Legal Code Description** - Required for regulatory mapping")
        
        # Trade Validation
        if not netting_set.trades:
            missing_fields.append("**At least one Trade** - Required for calculation")
        else:
            for i, trade in enumerate(netting_set.trades):
                trade_prefix = f"Trade {i+1} ({trade.trade_id})"
                if not trade.trade_id:
                    missing_fields.append(f"**{trade_prefix}: Trade ID** - Required for identification")
                if not trade.notional or trade.notional <= 0:
                    missing_fields.append(f"**{trade_prefix}: Notional Amount** - Must be > 0")
                if not trade.currency:
                    missing_fields.append(f"**{trade_prefix}: Currency** - Required for risk factor mapping")
                if not trade.maturity_date:
                    missing_fields.append(f"**{trade_prefix}: Maturity Date** - Required for time-to-maturity calculation")

        # Margining Information Validation
        if netting_set.is_margined:
            if netting_set.threshold is None:
                missing_fields.append("**Threshold Amount** - Required for margined calculations")
            if netting_set.mta is None:
                missing_fields.append("**Minimum Transfer Amount (MTA)** - Required for margined calculations")

        return {
            'is_complete': len(missing_fields) == 0,
            'missing_fields': missing_fields,
            'warnings': warnings
        }

    def calculate_structured_saccr(self, netting_set: NettingSet, collateral: List[Collateral] = None) -> Dict:
        """Calculate SA-CCR with structured bullet-point output format"""
        
        # First validate inputs
        validation_result = self.validate_input_completeness(netting_set, collateral)
        if not validation_result['is_complete']:
            return {
                'validation_failed': True,
                'missing_fields': validation_result['missing_fields'],
                'warnings': validation_result['warnings']
            }

        # Perform calculations
        calculation_steps = []
        
        # Generate Given Inputs section
        given_inputs = self._generate_given_inputs(netting_set)
        
        # Generate Collateral Portfolio section
        collateral_portfolio = self._generate_collateral_portfolio(collateral) if collateral else None
        
        # Generate Counterparty Details section
        counterparty_details = self._generate_counterparty_details(netting_set.counterparty_info)
        
        # Perform step-by-step calculations
        step_results = self._perform_step_calculations(netting_set, collateral)
        calculation_steps.extend(step_results['steps'])
        
        # Generate margined/unmargined statistics
        margining_stats = self._generate_margining_statistics(netting_set, collateral)
        
        # Generate final structured output
        structured_output = self._generate_structured_output(
            given_inputs, collateral_portfolio, counterparty_details,
            calculation_steps, step_results['final_values'], margining_stats
        )
        
        return {
            'validation_failed': False,
            'structured_output': structured_output,
            'final_results': step_results['final_values'],
            'calculation_steps': calculation_steps,
            'margining_statistics': margining_stats
        }

    def _generate_given_inputs(self, netting_set: NettingSet) -> str:
        """Generate formatted Given Inputs section"""
        total_notional = sum(abs(t.notional) for t in netting_set.trades)
        total_mtm = sum(t.mtm_value for t in netting_set.trades)
        
        inputs_text = f"""**📋 SA-CCR CALCULATION - {netting_set.netting_set_id}**

**Given Inputs:**
• **Netting Set ID**: {netting_set.netting_set_id}
• **Counterparty**: {netting_set.counterparty_info.name}
• **Total Number of Trades**: {len(netting_set.trades)}
• **Total Gross Notional**: ${total_notional:,.0f}
• **Total Net MTM**: ${total_mtm:,.0f}
• **Margining Status**: {"Margined" if netting_set.is_margined else "Unmargined"}"""

        if netting_set.is_margined:
            inputs_text += f"""
• **Threshold**: ${netting_set.threshold:,.0f}
• **Minimum Transfer Amount (MTA)**: ${netting_set.mta:,.0f}
• **Net Independent Collateral Amount (NICA)**: ${netting_set.nica:,.0f}"""

        # Add trade details
        inputs_text += "\n\n**Trade Portfolio Details:**"
        for i, trade in enumerate(netting_set.trades, 1):
            inputs_text += f"""
• **Trade {i}** ({trade.trade_id}):
  - Asset Class: {trade.asset_class.value}
  - Notional: ${trade.notional:,.0f} {trade.currency}
  - Maturity: {trade.time_to_maturity():.1f} years
  - MTM: ${trade.mtm_value:,.0f}"""

        return inputs_text

    def _generate_collateral_portfolio(self, collateral: List[Collateral]) -> str:
        """Generate formatted Collateral Portfolio section"""
        if not collateral:
            return None
            
        total_market_value = sum(c.market_value for c in collateral)
        total_effective_value = sum(c.market_value * (1 - c.haircut_percentage/100) for c in collateral)
        
        collateral_text = f"""**Collateral Portfolio:**
• **Total Market Value**: ${total_market_value:,.0f}
• **Total Effective Value (After Haircuts)**: ${total_effective_value:,.0f}

**Collateral Breakdown:**"""

        for i, coll in enumerate(collateral, 1):
            effective_value = coll.market_value * (1 - coll.haircut_percentage/100)
            collateral_text += f"""
• **Collateral {i}**: {coll.collateral_type.value}
  - Market Value: ${coll.market_value:,.0f} {coll.currency}
  - Regulatory Haircut: {coll.haircut_percentage}%
  - Effective Value: ${effective_value:,.0f}"""

        return collateral_text

    def _generate_counterparty_details(self, counterparty_info: CounterpartyInfo) -> str:
        """Generate formatted Counterparty Details section"""
        risk_info = self.risk_weight_mapping.get(counterparty_info.counterparty_type, 
                                                {'risk_weight': 1.0, 'category': 'Corporate Exposure'})
        
        details_text = f"""**Counterparty Information:**
• **Name**: {counterparty_info.name}
• **Country**: {counterparty_info.country}
• **Legal Code**: {counterparty_info.legal_code}
• **Legal Code Description**: {counterparty_info.legal_code_description}
• **Counterparty Type**: {counterparty_info.counterparty_type.value}
• **B3S Risk Weight Category**: {risk_info['category']}
• **B3S Risk Weight**: {risk_info['risk_weight']*100:.0f}%"""

        if counterparty_info.credit_rating:
            details_text += f"\n• **Credit Rating**: {counterparty_info.credit_rating}"

        return details_text

    def _perform_step_calculations(self, netting_set: NettingSet, collateral: List[Collateral]) -> Dict:
        """Perform step-by-step SA-CCR calculations"""
        steps = []
        
        # Step 1: Calculate Aggregate Add-On
        addon_result = self._calculate_aggregate_addon(netting_set.trades)
        steps.append({
            'step': 1,
            'title': 'Calculate Aggregate Add-On',
            'description': 'Sum all trade add-ons by asset class with supervisory factors',
            'formula': 'Aggregate Add-On = Σ(Notional × δ × MF × SF) by asset class',
            'calculation': f"Based on {len(netting_set.trades)} trades across asset classes",
            'result': f"${addon_result:,.0f}"
        })
        
        # Step 2: Calculate Sum of V and C
        sum_v = sum(trade.mtm_value for trade in netting_set.trades)
        sum_c = 0
        collateral_calcs = []
        
        if collateral:
            for coll in collateral:
                effective_value = coll.market_value * (1 - coll.haircut_percentage/100)
                sum_c += effective_value
                collateral_calcs.append(f"{coll.collateral_type.value}: ${coll.market_value:,.0f} × (1 - {coll.haircut_percentage}%) = ${effective_value:,.0f}")
        
        collateral_calc_text = "; ".join(collateral_calcs) if collateral_calcs else "No collateral"
        
        steps.append({
            'step': 2,
            'title': 'Calculate Sum of V (MTM) and C (Collateral)',
            'description': 'Sum all trade MTM values and effective collateral value',
            'formula': 'V = Σ(Trade MTM); C = Σ(Collateral × (1 - Haircut))',
            'calculation': f"V = ${sum_v:,.0f}; C = {collateral_calc_text}",
            'result': f"V = ${sum_v:,.0f}, C = ${sum_c:,.0f}"
        })
        
        # Step 3: Calculate PFE Multiplier
        v_minus_c = sum_v - sum_c
        if addon_result > 0:
            pfe_multiplier_floor = 0.05
            multiplier = min(1.0, pfe_multiplier_floor + (1 - pfe_multiplier_floor) * math.exp(v_minus_c / (2 * (1 - pfe_multiplier_floor) * addon_result)))
        else:
            multiplier = 1.0
            
        steps.append({
            'step': 3,
            'title': 'Calculate PFE Multiplier',
            'description': 'Calculate multiplier recognizing netting benefits',
            'formula': 'Multiplier = min(1, 0.05 + 0.95 × exp((V-C) / (2 × 0.95 × AddOn)))',
            'calculation': f"min(1, 0.05 + 0.95 × exp({v_minus_c:,.0f} / (2 × 0.95 × {addon_result:,.0f})))",
            'result': f"{multiplier:.6f}"
        })
        
        # Step 4: Calculate PFE
        pfe = multiplier * addon_result
        steps.append({
            'step': 4,
            'title': 'Calculate Potential Future Exposure (PFE)',
            'description': 'Apply multiplier to aggregate add-on',
            'formula': 'PFE = Multiplier × Aggregate Add-On',
            'calculation': f"{multiplier:.6f} × ${addon_result:,.0f}",
            'result': f"${pfe:,.0f}"
        })
        
        # Step 5: Calculate Replacement Cost (RC)
        if netting_set.is_margined and netting_set.threshold is not None and netting_set.mta is not None:
            rc = max(sum_v - sum_c, netting_set.threshold + netting_set.mta - netting_set.nica, 0)
            rc_formula = "RC = max(V - C, TH + MTA - NICA, 0)"
            rc_calc = f"max(${sum_v:,.0f} - ${sum_c:,.0f}, ${netting_set.threshold:,.0f} + ${netting_set.mta:,.0f} - ${netting_set.nica:,.0f}, 0)"
        else:
            rc = max(sum_v - sum_c, 0)
            rc_formula = "RC = max(V - C, 0)"
            rc_calc = f"max(${sum_v:,.0f} - ${sum_c:,.0f}, 0)"
        
        steps.append({
            'step': 5,
            'title': 'Calculate Replacement Cost (RC)',
            'description': 'Calculate current exposure with netting and collateral benefits',
            'formula': rc_formula,
            'calculation': rc_calc,
            'result': f"${rc:,.0f}"
        })
        
        # Step 6: Calculate EAD
        alpha = 1.4
        ead = alpha * (rc + pfe)
        steps.append({
            'step': 6,
            'title': 'Calculate Exposure at Default (EAD)',
            'description': 'Apply regulatory alpha factor to total exposure',
            'formula': 'EAD = α × (RC + PFE)',
            'calculation': f"{alpha} × (${rc:,.0f} + ${pfe:,.0f})",
            'result': f"${ead:,.0f}"
        })
        
        # Step 7: Apply Risk Weight and Calculate RWA
        risk_info = self.risk_weight_mapping.get(netting_set.counterparty_info.counterparty_type,
                                                {'risk_weight': 1.0, 'category': 'Corporate Exposure'})
        risk_weight = risk_info['risk_weight']
        rwa = ead * risk_weight
        
        steps.append({
            'step': 7,
            'title': 'Calculate Risk Weighted Assets (RWA)',
            'description': f'Apply {risk_info["category"]} risk weight',
            'formula': 'RWA = EAD × Risk Weight',
            'calculation': f"${ead:,.0f} × {risk_weight*100:.0f}%",
            'result': f"${rwa:,.0f}"
        })
        
        # Step 8: Calculate Capital Requirement
        capital_req = rwa * 0.08
        steps.append({
            'step': 8,
            'title': 'Calculate Capital Requirement',
            'description': 'Apply 8% capital ratio to RWA',
            'formula': 'Capital Requirement = RWA × 8%',
            'calculation': f"${rwa:,.0f} × 8%",
            'result': f"${capital_req:,.0f}"
        })
        
        return {
            'steps': steps,
            'final_values': {
                'aggregate_addon': addon_result,
                'pfe_multiplier': multiplier,
                'potential_future_exposure': pfe,
                'replacement_cost': rc,
                'exposure_at_default': ead,
                'risk_weighted_assets': rwa,
                'capital_requirement': capital_req
            }
        }

    def _calculate_aggregate_addon(self, trades: List[Trade]) -> float:
        """Simplified aggregate add-on calculation"""
        total_addon = 0
        for trade in trades:
            # Simplified calculation using notional and supervisory factor
            sf = self._get_supervisory_factor(trade) / 100  # Convert to decimal
            mf = math.sqrt(min(trade.time_to_maturity(), 1.0))  # Maturity factor
            addon = abs(trade.notional) * trade.delta * mf * sf
            total_addon += addon
        return total_addon

    def _get_supervisory_factor(self, trade: Trade) -> float:
        """Get supervisory factor in percentage"""
        if trade.asset_class == AssetClass.INTEREST_RATE:
            maturity = trade.time_to_maturity()
            if maturity < 2: return 0.5
            elif maturity <= 5: return 0.5
            else: return 1.5
        elif trade.asset_class == AssetClass.FOREIGN_EXCHANGE:
            return 4.0
        elif trade.asset_class == AssetClass.CREDIT:
            return 0.46
        elif trade.asset_class == AssetClass.EQUITY:
            return 32.0
        elif trade.asset_class == AssetClass.COMMODITY:
            return 18.0
        return 1.0

    def _generate_margining_statistics(self, netting_set: NettingSet, collateral: List[Collateral]) -> Dict:
        """Generate margined vs unmargined statistics"""
        sum_v = sum(trade.mtm_value for trade in netting_set.trades)
        sum_c = sum(c.market_value * (1 - c.haircut_percentage/100) for c in collateral) if collateral else 0
        
        # Calculate both margined and unmargined RC for comparison
        rc_unmargined = max(sum_v - sum_c, 0)
        
        if netting_set.is_margined and netting_set.threshold is not None and netting_set.mta is not None:
            rc_margined = max(sum_v - sum_c, netting_set.threshold + netting_set.mta - netting_set.nica, 0)
        else:
            rc_margined = None
        
        return {
            'is_margined': netting_set.is_margined,
            'unmargined_rc': rc_unmargined,
            'margined_rc': rc_margined,
            'sum_v': sum_v,
            'sum_c': sum_c,
            'threshold': netting_set.threshold,
            'mta': netting_set.mta,
            'nica': netting_set.nica
        }

    def _generate_structured_output(self, given_inputs: str, collateral_portfolio: str,
                                    counterparty_details: str, calculation_steps: List[Dict],
                                    final_values: Dict, margining_stats: Dict) -> str:
        """Generate complete structured output in the requested format"""
        
        output = given_inputs + "\n\n"
        
        if collateral_portfolio:
            output += collateral_portfolio + "\n\n"
        
        output += counterparty_details + "\n\n"
        
        output += "🔍 **STEP-BY-STEP CALCULATION:**\n\n"
        
        for step in calculation_steps:
            output += f"**Step {step['step']}: {step['title']}**\n"
            output += f"• **Description**: {step['description']}\n"
            output += f"• **Formula**: `{step['formula']}`\n"
            output += f"• **Calculation**: {step['calculation']}\n"
            output += f"• **Result: {step['result']}**\n\n"
        
        # Add margining comparison if applicable
        if margining_stats['margined_rc'] is not None:
            output += "📊 **MARGINED VS UNMARGINED COMPARISON:**\n"
            output += f"• **Unmargined RC**: ${margining_stats['unmargined_rc']:,.0f}\n"
            output += f"• **Margined RC**: ${margining_stats['margined_rc']:,.0f}\n"
            benefit = margining_stats['unmargined_rc'] - margining_stats['margined_rc']
            output += f"• **Margining Benefit**: ${benefit:,.0f}\n\n"
        
        output += f"✅ **FINAL RESULT: RWA = ${final_values['risk_weighted_assets']:,.0f}**\n"
        output += f"💰 **Capital Requirement = ${final_values['capital_requirement']:,.0f}**"
        
        return output

# ==============================================================================
# STREAMLIT APPLICATION
# ==============================================================================

def main():
    """Main function to run the enhanced Streamlit app."""
    st.markdown("""
    <div class="structured-header">
        <h1>🧮 Enhanced SA-CCR Platform</h1>
        <p>Complete Basel SA-CCR Calculator with Structured Bullet-Point Output</p>
    </div>
    """, unsafe_allow_html=True)
    
    if 'enhanced_agent' not in st.session_state:
        st.session_state.enhanced_agent = EnhancedSACCRAgent()
    
    with st.sidebar:
        st.markdown("### 🔧 Configuration")
        with st.expander("🤖 LLM Setup", expanded=False):
            base_url = st.text_input("Base URL", value="http://localhost:8123/v1")
            api_key = st.text_input("API Key", value="not-needed", type="password")
            model = st.text_input("Model", value="llama3")
            
            if st.button("🔗 Connect LLM"):
                config = {
                    'base_url': base_url, 'api_key': api_key,
                    'model': model, 'temperature': 0.3,
                    'max_tokens': 4000, 'streaming': False
                }
                with st.spinner("Connecting..."):
                    success = st.session_state.enhanced_agent.setup_llm_connection(config)
                    if success:
                        st.success("✅ Connected!")
                    else:
                        st.error("❌ Failed")
        
        st.markdown("---")
        page = st.selectbox("Select Module:", [
            "🧮 SA-CCR Calculator",
            "🤖 AI Assistant",
            "📋 Load Example",
            "📊 Results Viewer"
        ])
    
    if page == "🧮 SA-CCR Calculator":
        saccr_calculator()
    elif page == "🤖 AI Assistant":
        ai_assistant_page()
    elif page == "📋 Load Example":
        load_example()
    elif page == "📊 Results Viewer":
        results_viewer()

def ai_assistant_page():
    """AI assistant for SA-CCR questions and intelligent portfolio analysis"""
    st.markdown('<div class="section-header">🤖 AI SA-CCR Expert Assistant</div>', unsafe_allow_html=True)
    
    # Connection status display
    status = st.session_state.enhanced_agent.connection_status
    if status == "connected":
        st.success("🟢 **AI Assistant Connected** - Describe your trades and I'll calculate RWA!")
    else:
        st.warning("🟡 **AI Assistant Offline** - Connect LLM in sidebar for full AI functionality")
    
    # Initialize session states
    if 'extracted_info' not in st.session_state:
        st.session_state.extracted_info = {}
    if 'ai_chat_history' not in st.session_state:
        st.session_state.ai_chat_history = [
            {
                "role": "assistant", 
                "content": "Hello! I'm your SA-CCR expert assistant. **Just describe your derivatives portfolio or trades**, and I'll ask follow-up questions to calculate your RWA accurately. Try: *'I have a $100M swap with Deutsche Bank'*"
            }
        ]
    
    # Sample usage guide
    with st.expander("💡 How to Use - Just Describe Your Trades", expanded=True):
        col1, col2 = st.columns(2)
        with col1:
            st.markdown("""
            **Examples of what you can say:**
            • "I have a $100M interest rate swap with Bank ABC"
            • "Calculate RWA for 3 FX forwards, total $50M"
            • "My portfolio has margined swaps with 1M threshold"
            • "Need SA-CCR capital for commodity derivatives"
            """)
        
        with col2:
            st.markdown("""
            **I'll automatically:**
            • Extract trade information from your description
            • Ask for missing critical details
            • Make reasonable assumptions where needed
            • Generate complete structured RWA calculation
            """)
    
    # Information collection status
    if st.session_state.extracted_info:
        with st.expander("📋 Information I've Collected", expanded=True):
            for key, value in st.session_state.extracted_info.items():
                formatted_key = key.replace('_', ' ').title()
                if hasattr(value, 'value'):  # Enum
                    formatted_value = value.value
                elif key == 'notional':
                    formatted_value = f"${value:,.0f}"
                else:
                    formatted_value = str(value)
                st.write(f"• {formatted_key}: {formatted_value}")
    
    # Chat interface
    st.markdown("### 💬 Chat Interface")
    
    # Display chat history
    for message in st.session_state.ai_chat_history:
        with st.chat_message(message["role"]):
            st.markdown(message["content"])

    # Chat input
    if prompt := st.chat_input("Describe your trades or ask SA-CCR questions..."):
        # Add user message
        st.session_state.ai_chat_history.append({"role": "user", "content": prompt})
        
        with st.chat_message("user"):
            st.markdown(prompt)

        # Generate response
        with st.chat_message("assistant"):
            with st.spinner("Analyzing your input..."):
                ai_response = process_user_input(prompt)
                st.markdown(ai_response)
        
        st.session_state.ai_chat_history.append({"role": "assistant", "content": ai_response})
    
    # Quick actions
    st.markdown("---")
    col1, col2, col3, col4, col5 = st.columns(5)
    
    with col1:
        if st.button("📚 SA-CCR Basics"):
            response = get_saccr_basics_explanation()
            st.session_state.ai_chat_history.append({"role": "assistant", "content": response})
            st.rerun()
    
    with col2:
        if st.button("🔧 Optimization"):
            response = get_optimization_tips()
            st.session_state.ai_chat_history.append({"role": "assistant", "content": response})
            st.rerun()

    with col3:
        if st.button("📈 Risk Drivers"):
            response = get_risk_drivers_explanation()
            st.session_state.ai_chat_history.append({"role": "assistant", "content": response})
            st.rerun()
    
    with col4:
        if st.button("📊 Calculate RWA"):
            if st.session_state.extracted_info:
                response = generate_rwa_calculation_with_assumptions()
            else:
                response = "Please describe your trades first, then I can calculate RWA."
            st.session_state.ai_chat_history.append({"role": "assistant", "content": response})
            st.rerun()
    
    with col5:
        if st.button("🧹 Clear"):
            st.session_state.extracted_info = {}
            st.session_state.ai_chat_history = [
                {"role": "assistant", "content": "Cleared! Ready for new SA-CCR calculation."}
            ]
            st.rerun()

def generate_ai_response(question: str) -> str:
    """Generate AI response using connected LLM"""
    system_prompt = """You are a world-class Basel III SA-CCR regulatory expert with deep knowledge of:
    - Complete 24-step SA-CCR calculation methodology
    - Regulatory requirements and interpretations
    - Risk management optimization strategies
    - Technical implementation details
    - Cross-asset class derivative structures

    Provide clear, accurate, and actionable responses. Use technical terms appropriately but explain complex concepts clearly. Include formulas, examples, or step-by-step guidance when helpful. Structure your responses with headings and bullet points for clarity."""
    
    try:
        response = st.session_state.enhanced_agent.llm.invoke([
            SystemMessage(content=system_prompt),
            HumanMessage(content=question)
        ])
        return response.content
    except Exception as e:
        return f"**AI Response Error**: {str(e)}\n\nPlease check your LLM connection settings in the sidebar."

def generate_template_response(question: str) -> str:
    """Generate template responses when LLM is not available"""
    question_lower = question.lower()
    
    if "pfe multiplier" in question_lower or "multiplier" in question_lower:
        return """
**PFE Multiplier Explanation** *(LLM Offline - Template Response)*

The **PFE Multiplier** recognizes netting benefits in SA-CCR calculations:

**📊 Formula:**
