# ==============================================================================
# Enhanced AI-Powered SA-CCR Platform with Structured Output Format
#
# This script creates a complete SA-CCR application with structured bullet-point
# output format, comprehensive input validation, and detailed counterparty information.
#
# To Run:
# 1. Install dependencies: pip install streamlit pandas plotly langchain langchain-openai
# 2. Save this file as `enhanced_saccr_app.py`
# 3. Run from terminal: streamlit run enhanced_saccr_app.py
# ==============================================================================

import streamlit as st
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta
import json
from dataclasses import dataclass
from typing import Dict, List, Optional
from enum import Enum
import math
import re

# LangChain imports for LLM integration
from langchain_openai import ChatOpenAI
from langchain.schema import HumanMessage, SystemMessage

# ==============================================================================
# ENHANCED UI CONFIGURATION
# ==============================================================================

st.set_page_config(
    page_title="Enhanced SA-CCR Platform",
    page_icon="🧮",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Enhanced CSS for professional styling
st.markdown("""
<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
    
    .main { font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; }
    
    .structured-header {
        background: linear-gradient(135deg, #2E86AB 0%, #A23B72 100%);
        color: white;
        padding: 2rem;
        border-radius: 12px;
        margin-bottom: 1.5rem;
        box-shadow: 0 8px 32px rgba(0,0,0,0.1);
    }
    
    .section-header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 1rem;
        border-radius: 8px;
        margin: 1rem 0;
        font-weight: 600;
        font-size: 1.1rem;
    }
    
    .given-inputs {
        background: #f8f9ff;
        border-left: 4px solid #4CAF50;
        padding: 1.5rem;
        margin: 1rem 0;
        border-radius: 8px;
    }
    
    .collateral-info {
        background: #fff8e1;
        border-left: 4px solid #FF9800;
        padding: 1.5rem;
        margin: 1rem 0;
        border-radius: 8px;
    }
    
    .calculation-step {
        background: #ffffff;
        border: 1px solid #e1e5e9;
        padding: 1.5rem;
        margin: 0.5rem 0;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    
    .step-title {
        font-size: 1.2rem;
        font-weight: 600;
        color: #1976d2;
        margin-bottom: 0.5rem;
    }
    
    .formula-box {
        background: #f5f5f5;
        padding: 1rem;
        border-radius: 6px;
        font-family: 'Monaco', 'Menlo', monospace;
        border-left: 3px solid #2196F3;
        margin: 0.5rem 0;
    }
    
    .result-highlight {
        background: #e8f5e8;
        padding: 0.8rem;
        border-radius: 6px;
        font-weight: 600;
        color: #2e7d32;
        margin: 0.5rem 0;
    }
    
    .final-result {
        background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
        color: white;
        padding: 1.5rem;
        border-radius: 12px;
        margin: 1rem 0;
        text-align: center;
        font-size: 1.3rem;
        font-weight: 700;
        box-shadow: 0 4px 16px rgba(76, 175, 80, 0.3);
    }
    
    .missing-info {
        background: #ffebee;
        border-left: 4px solid #f44336;
        padding: 1rem;
        margin: 1rem 0;
        border-radius: 8px;
    }
    
    .counterparty-details {
        background: #e3f2fd;
        border-left: 4px solid #2196F3;
        padding: 1.5rem;
        margin: 1rem 0;
        border-radius: 8px;
    }
</style>
""", unsafe_allow_html=True)

# ==============================================================================
# ENHANCED DATA CLASSES
# ==============================================================================

class AssetClass(Enum):
    INTEREST_RATE = "Interest Rate"
    FOREIGN_EXCHANGE = "Foreign Exchange"
    CREDIT = "Credit"
    EQUITY = "Equity"
    COMMODITY = "Commodity"

class TradeType(Enum):
    SWAP = "Swap"
    FORWARD = "Forward"
    OPTION = "Option"
    SWAPTION = "Swaption"

class CollateralType(Enum):
    CASH = "Cash"
    GOVERNMENT_BONDS = "Government Bonds"
    CORPORATE_BONDS = "Corporate Bonds"
    EQUITIES = "Equities"
    MONEY_MARKET = "Money Market Funds"

class CounterpartyType(Enum):
    CORPORATE = "Corporate"
    BANK = "Bank"
    SOVEREIGN = "Sovereign"
    RETAIL = "Retail"
    OTHER_FINANCIAL = "Other Financial Institution"

@dataclass
class CounterpartyInfo:
    name: str
    country: str = ""
    legal_code: str = ""
    legal_code_description: str = ""
    counterparty_type: CounterpartyType = CounterpartyType.CORPORATE
    credit_rating: str = ""
    b3s_risk_weight_category: str = ""
    b3s_risk_weight: float = 1.0

@dataclass
class Trade:
    trade_id: str
    counterparty: str
    asset_class: AssetClass
    trade_type: TradeType
    notional: float
    currency: str
    underlying: str
    maturity_date: datetime
    mtm_value: float = 0.0
    delta: float = 1.0
    basis_flag: bool = False
    volatility_flag: bool = False
    ceu_flag: int = 1

    def time_to_maturity(self) -> float:
        return max(0, (self.maturity_date - datetime.now()).days / 365.25)

@dataclass
class NettingSet:
    netting_set_id: str
    counterparty_info: CounterpartyInfo
    trades: List[Trade]
    threshold: Optional[float] = None
    mta: Optional[float] = None
    nica: float = 0.0
    is_margined: bool = False

@dataclass
class Collateral:
    collateral_type: CollateralType
    currency: str
    amount: float
    market_value: float = None
    haircut_percentage: float = None

    def __post_init__(self):
        if self.market_value is None:
            self.market_value = self.amount
        if self.haircut_percentage is None:
            self.haircut_percentage = self._get_default_haircut()

    def _get_default_haircut(self) -> float:
        haircut_mapping = {
            CollateralType.CASH: 0.0,
            CollateralType.GOVERNMENT_BONDS: 0.5,
            CollateralType.CORPORATE_BONDS: 4.0,
            CollateralType.EQUITIES: 15.0,
            CollateralType.MONEY_MARKET: 0.5
        }
        return haircut_mapping.get(self.collateral_type, 15.0)

# ==============================================================================
# ENHANCED SA-CCR AGENT WITH STRUCTURED OUTPUT
# ==============================================================================

class EnhancedSACCRAgent:
    """Enhanced SA-CCR Agent with structured bullet-point output format"""

    def __init__(self):
        self.llm = None
        self.connection_status = "disconnected"
        self.supervisory_factors = self._initialize_supervisory_factors()
        self.supervisory_correlations = self._initialize_correlations()
        self.collateral_haircuts = self._initialize_collateral_haircuts()
        self.risk_weight_mapping = self._initialize_risk_weight_mapping()

    def setup_llm_connection(self, config: Dict) -> bool:
        """Setup LangChain ChatOpenAI connection"""
        try:
            self.llm = ChatOpenAI(
                base_url=config.get('base_url', "http://localhost:8123/v1"),
                api_key=config.get('api_key', "not-needed"),
                model=config.get('model', "llama3"),
                temperature=config.get('temperature', 0.3),
                max_tokens=config.get('max_tokens', 4000),
                streaming=config.get('streaming', False)
            )
            
            test_response = self.llm.invoke([
                SystemMessage(content="You are a helpful assistant. Respond with 'Connected' if you receive this."),
                HumanMessage(content="Test")
            ])
            
            if "Connected" in test_response.content:
                self.connection_status = "connected"
                return True
            else:
                self.connection_status = "disconnected"
                return False
                
        except Exception as e:
            st.error(f"LLM Connection Error: {str(e)}")
            self.connection_status = "disconnected"
            return False

    def _initialize_supervisory_factors(self) -> Dict:
        return {
            AssetClass.INTEREST_RATE: {
                'USD': {'<2y': 0.50, '2-5y': 0.50, '>5y': 1.50},
                'EUR': {'<2y': 0.50, '2-5y': 0.50, '>5y': 1.50},
                'JPY': {'<2y': 0.50, '2-5y': 0.50, '>5y': 1.50},
                'GBP': {'<2y': 0.50, '2-5y': 0.50, '>5y': 1.50},
                'other': {'<2y': 1.50, '2-5y': 1.50, '>5y': 1.50}
            },
            AssetClass.FOREIGN_EXCHANGE: {'G10': 4.0, 'emerging': 15.0},
            AssetClass.CREDIT: {'IG_single': 0.46, 'HY_single': 1.30},
            AssetClass.EQUITY: {'single_large': 32.0, 'single_small': 40.0},
            AssetClass.COMMODITY: {'energy': 18.0}
        }

    def _initialize_correlations(self) -> Dict:
        return {
            AssetClass.INTEREST_RATE: 0.99,
            AssetClass.FOREIGN_EXCHANGE: 0.60,
            AssetClass.CREDIT: 0.50,
            AssetClass.EQUITY: 0.80,
            AssetClass.COMMODITY: 0.40
        }

    def _initialize_collateral_haircuts(self) -> Dict:
        return {
            CollateralType.CASH: 0.0,
            CollateralType.GOVERNMENT_BONDS: 0.5,
            CollateralType.CORPORATE_BONDS: 4.0,
            CollateralType.EQUITIES: 15.0,
            CollateralType.MONEY_MARKET: 0.5
        }

    def _initialize_risk_weight_mapping(self) -> Dict:
        return {
            CounterpartyType.CORPORATE: {'risk_weight': 1.0, 'category': 'Corporate Exposure'},
            CounterpartyType.BANK: {'risk_weight': 0.20, 'category': 'Bank Exposure'},
            CounterpartyType.SOVEREIGN: {'risk_weight': 0.0, 'category': 'Sovereign Exposure'},
            CounterpartyType.RETAIL: {'risk_weight': 0.75, 'category': 'Retail Exposure'},
            CounterpartyType.OTHER_FINANCIAL: {'risk_weight': 1.25, 'category': 'Other Financial Institution'}
        }

    def validate_input_completeness(self, netting_set: NettingSet, collateral: List[Collateral] = None) -> Dict:
        """Comprehensive input validation with specific missing field identification"""
        missing_fields = []
        warnings = []
        
        # Netting Set Validation
        if not netting_set.netting_set_id:
            missing_fields.append("**Netting Set ID** - Required for identification")
        
        # Counterparty Information Validation
        if not netting_set.counterparty_info.name:
            missing_fields.append("**Counterparty Name** - Required for calculation")
        if not netting_set.counterparty_info.country:
            missing_fields.append("**Counterparty Country** - Required for regulatory classification")
        if not netting_set.counterparty_info.legal_code:
            missing_fields.append("**Legal Entity Code** - Required for risk weight determination")
        if not netting_set.counterparty_info.legal_code_description:
            missing_fields.append("**Legal Code Description** - Required for regulatory mapping")
        
        # Trade Validation
        if not netting_set.trades:
            missing_fields.append("**At least one Trade** - Required for calculation")
        else:
            for i, trade in enumerate(netting_set.trades):
                trade_prefix = f"Trade {i+1} ({trade.trade_id})"
                if not trade.trade_id:
                    missing_fields.append(f"**{trade_prefix}: Trade ID** - Required for identification")
                if not trade.notional or trade.notional <= 0:
                    missing_fields.append(f"**{trade_prefix}: Notional Amount** - Must be > 0")
                if not trade.currency:
                    missing_fields.append(f"**{trade_prefix}: Currency** - Required for risk factor mapping")
                if not trade.maturity_date:
                    missing_fields.append(f"**{trade_prefix}: Maturity Date** - Required for time-to-maturity calculation")

        # Margining Information Validation
        if netting_set.is_margined:
            if netting_set.threshold is None:
                missing_fields.append("**Threshold Amount** - Required for margined calculations")
            if netting_set.mta is None:
                missing_fields.append("**Minimum Transfer Amount (MTA)** - Required for margined calculations")

        return {
            'is_complete': len(missing_fields) == 0,
            'missing_fields': missing_fields,
            'warnings': warnings
        }

    def calculate_structured_saccr(self, netting_set: NettingSet, collateral: List[Collateral] = None) -> Dict:
        """Calculate SA-CCR with structured bullet-point output format"""
        
        # First validate inputs
        validation_result = self.validate_input_completeness(netting_set, collateral)
        if not validation_result['is_complete']:
            return {
                'validation_failed': True,
                'missing_fields': validation_result['missing_fields'],
                'warnings': validation_result['warnings']
            }

        # Perform calculations
        calculation_steps = []
        
        # Generate Given Inputs section
        given_inputs = self._generate_given_inputs(netting_set)
        
        # Generate Collateral Portfolio section
        collateral_portfolio = self._generate_collateral_portfolio(collateral) if collateral else None
        
        # Generate Counterparty Details section
        counterparty_details = self._generate_counterparty_details(netting_set.counterparty_info)
        
        # Perform step-by-step calculations
        step_results = self._perform_step_calculations(netting_set, collateral)
        calculation_steps.extend(step_results['steps'])
        
        # Generate margined/unmargined statistics
        margining_stats = self._generate_margining_statistics(netting_set, collateral)
        
        # Generate final structured output
        structured_output = self._generate_structured_output(
            given_inputs, collateral_portfolio, counterparty_details,
            calculation_steps, step_results['final_values'], margining_stats
        )
        
        return {
            'validation_failed': False,
            'structured_output': structured_output,
            'final_results': step_results['final_values'],
            'calculation_steps': calculation_steps,
            'margining_statistics': margining_stats
        }

    def _generate_given_inputs(self, netting_set: NettingSet) -> str:
        """Generate formatted Given Inputs section"""
        total_notional = sum(abs(t.notional) for t in netting_set.trades)
        total_mtm = sum(t.mtm_value for t in netting_set.trades)
        
        inputs_text = f"""**📋 SA-CCR CALCULATION - {netting_set.netting_set_id}**

**Given Inputs:**
• **Netting Set ID**: {netting_set.netting_set_id}
• **Counterparty**: {netting_set.counterparty_info.name}
• **Total Number of Trades**: {len(netting_set.trades)}
• **Total Gross Notional**: ${total_notional:,.0f}
• **Total Net MTM**: ${total_mtm:,.0f}
• **Margining Status**: {"Margined" if netting_set.is_margined else "Unmargined"}"""

        if netting_set.is_margined:
            inputs_text += f"""
• **Threshold**: ${netting_set.threshold:,.0f}
• **Minimum Transfer Amount (MTA)**: ${netting_set.mta:,.0f}
• **Net Independent Collateral Amount (NICA)**: ${netting_set.nica:,.0f}"""

        # Add trade details
        inputs_text += "\n\n**Trade Portfolio Details:**"
        for i, trade in enumerate(netting_set.trades, 1):
            inputs_text += f"""
• **Trade {i}** ({trade.trade_id}):
  - Asset Class: {trade.asset_class.value}
  - Notional: ${trade.notional:,.0f} {trade.currency}
  - Maturity: {trade.time_to_maturity():.1f} years
  - MTM: ${trade.mtm_value:,.0f}"""

        return inputs_text

    def _generate_collateral_portfolio(self, collateral: List[Collateral]) -> str:
        """Generate formatted Collateral Portfolio section"""
        if not collateral:
            return None
            
        total_market_value = sum(c.market_value for c in collateral)
        total_effective_value = sum(c.market_value * (1 - c.haircut_percentage/100) for c in collateral)
        
        collateral_text = f"""**Collateral Portfolio:**
• **Total Market Value**: ${total_market_value:,.0f}
• **Total Effective Value (After Haircuts)**: ${total_effective_value:,.0f}

**Collateral Breakdown:**"""

        for i, coll in enumerate(collateral, 1):
            effective_value = coll.market_value * (1 - coll.haircut_percentage/100)
            collateral_text += f"""
• **Collateral {i}**: {coll.collateral_type.value}
  - Market Value: ${coll.market_value:,.0f} {coll.currency}
  - Regulatory Haircut: {coll.haircut_percentage}%
  - Effective Value: ${effective_value:,.0f}"""

        return collateral_text

    def _generate_counterparty_details(self, counterparty_info: CounterpartyInfo) -> str:
        """Generate formatted Counterparty Details section"""
        risk_info = self.risk_weight_mapping.get(counterparty_info.counterparty_type, 
                                                {'risk_weight': 1.0, 'category': 'Corporate Exposure'})
        
        details_text = f"""**Counterparty Information:**
• **Name**: {counterparty_info.name}
• **Country**: {counterparty_info.country}
• **Legal Code**: {counterparty_info.legal_code}
• **Legal Code Description**: {counterparty_info.legal_code_description}
• **Counterparty Type**: {counterparty_info.counterparty_type.value}
• **B3S Risk Weight Category**: {risk_info['category']}
• **B3S Risk Weight**: {risk_info['risk_weight']*100:.0f}%"""

        if counterparty_info.credit_rating:
            details_text += f"\n• **Credit Rating**: {counterparty_info.credit_rating}"

        return details_text

    def _perform_step_calculations(self, netting_set: NettingSet, collateral: List[Collateral]) -> Dict:
        """Perform step-by-step SA-CCR calculations"""
        steps = []
        
        # Step 1: Calculate Aggregate Add-On
        addon_result = self._calculate_aggregate_addon(netting_set.trades)
        steps.append({
            'step': 1,
            'title': 'Calculate Aggregate Add-On',
            'description': 'Sum all trade add-ons by asset class with supervisory factors',
            'formula': 'Aggregate Add-On = Σ(Notional × δ × MF × SF) by asset class',
            'calculation': f"Based on {len(netting_set.trades)} trades across asset classes",
            'result': f"${addon_result:,.0f}"
        })
        
        # Step 2: Calculate Sum of V and C
        sum_v = sum(trade.mtm_value for trade in netting_set.trades)
        sum_c = 0
        collateral_calcs = []
        
        if collateral:
            for coll in collateral:
                effective_value = coll.market_value * (1 - coll.haircut_percentage/100)
                sum_c += effective_value
                collateral_calcs.append(f"{coll.collateral_type.value}: ${coll.market_value:,.0f} × (1 - {coll.haircut_percentage}%) = ${effective_value:,.0f}")
        
        collateral_calc_text = "; ".join(collateral_calcs) if collateral_calcs else "No collateral"
        
        steps.append({
            'step': 2,
            'title': 'Calculate Sum of V (MTM) and C (Collateral)',
            'description': 'Sum all trade MTM values and effective collateral value',
            'formula': 'V = Σ(Trade MTM); C = Σ(Collateral × (1 - Haircut))',
            'calculation': f"V = ${sum_v:,.0f}; C = {collateral_calc_text}",
            'result': f"V = ${sum_v:,.0f}, C = ${sum_c:,.0f}"
        })
        
        # Step 3: Calculate PFE Multiplier
        v_minus_c = sum_v - sum_c
        if addon_result > 0:
            pfe_multiplier_floor = 0.05
            # Using the corrected formula for the PFE multiplier
            multiplier = min(1.0, pfe_multiplier_floor + (1 - pfe_multiplier_floor) * math.exp(v_minus_c / (2 * (1 - pfe_multiplier_floor) * addon_result)))
        else:
            multiplier = 1.0
            
        steps.append({
            'step': 3,
            'title': 'Calculate PFE Multiplier',
            'description': 'Calculate multiplier recognizing netting benefits',
            'formula': 'Multiplier = min(1, 0.05 + 0.95 × exp((V-C) / (2 × 0.95 × AddOn)))',
            'calculation': f"min(1, 0.05 + 0.95 × exp({v_minus_c:,.0f} / (2 × 0.95 × {addon_result:,.0f})))",
            'result': f"{multiplier:.6f}"
        })
        
        # Step 4: Calculate PFE
        pfe = multiplier * addon_result
        steps.append({
            'step': 4,
            'title': 'Calculate Potential Future Exposure (PFE)',
            'description': 'Apply multiplier to aggregate add-on',
            'formula': 'PFE = Multiplier × Aggregate Add-On',
            'calculation': f"{multiplier:.6f} × ${addon_result:,.0f}",
            'result': f"${pfe:,.0f}"
        })
        
        # Step 5: Calculate Replacement Cost (RC)
        if netting_set.is_margined and netting_set.threshold is not None and netting_set.mta is not None:
            rc = max(sum_v - sum_c, netting_set.threshold + netting_set.mta - netting_set.nica, 0)
            rc_formula = "RC = max(V - C, TH + MTA - NICA, 0)"
            rc_calc = f"max(${sum_v:,.0f} - ${sum_c:,.0f}, ${netting_set.threshold:,.0f} + ${netting_set.mta:,.0f} - ${netting_set.nica:,.0f}, 0)"
        else:
            rc = max(sum_v - sum_c, 0)
            rc_formula = "RC = max(V - C, 0)"
            rc_calc = f"max(${sum_v:,.0f} - ${sum_c:,.0f}, 0)"
        
        steps.append({
            'step': 5,
            'title': 'Calculate Replacement Cost (RC)',
            'description': 'Calculate current exposure with netting and collateral benefits',
            'formula': rc_formula,
            'calculation': rc_calc,
            'result': f"${rc:,.0f}"
        })
        
        # Step 6: Calculate EAD
        alpha = 1.4
        ead = alpha * (rc + pfe)
        steps.append({
            'step': 6,
            'title': 'Calculate Exposure at Default (EAD)',
            'description': 'Apply regulatory alpha factor to total exposure',
            'formula': 'EAD = α × (RC + PFE)',
            'calculation': f"{alpha} × (${rc:,.0f} + ${pfe:,.0f})",
            'result': f"${ead:,.0f}"
        })
        
        # Step 7: Apply Risk Weight and Calculate RWA
        risk_info = self.risk_weight_mapping.get(netting_set.counterparty_info.counterparty_type,
                                                {'risk_weight': 1.0, 'category': 'Corporate Exposure'})
        risk_weight = risk_info['risk_weight']
        rwa = ead * risk_weight
        
        steps.append({
            'step': 7,
            'title': 'Calculate Risk Weighted Assets (RWA)',
            'description': f'Apply {risk_info["category"]} risk weight',
            'formula': 'RWA = EAD × Risk Weight',
            'calculation': f"${ead:,.0f} × {risk_weight*100:.0f}%",
            'result': f"${rwa:,.0f}"
        })
        
        # Step 8: Calculate Capital Requirement
        capital_req = rwa * 0.08
        steps.append({
            'step': 8,
            'title': 'Calculate Capital Requirement',
            'description': 'Apply 8% capital ratio to RWA',
            'formula': 'Capital Requirement = RWA × 8%',
            'calculation': f"${rwa:,.0f} × 8%",
            'result': f"${capital_req:,.0f}"
        })
        
        return {
            'steps': steps,
            'final_values': {
                'aggregate_addon': addon_result,
                'pfe_multiplier': multiplier,
                'potential_future_exposure': pfe,
                'replacement_cost': rc,
                'exposure_at_default': ead,
                'risk_weighted_assets': rwa,
                'capital_requirement': capital_req
            }
        }

    def _calculate_aggregate_addon(self, trades: List[Trade]) -> float:
        """Simplified aggregate add-on calculation"""
        total_addon = 0
        for trade in trades:
            # Simplified calculation using notional and supervisory factor
            sf = self._get_supervisory_factor(trade) / 100  # Convert to decimal
            mf = math.sqrt(min(trade.time_to_maturity(), 1.0))  # Maturity factor
            addon = abs(trade.notional) * trade.delta * mf * sf
            total_addon += addon
        return total_addon

    def _get_supervisory_factor(self, trade: Trade) -> float:
        """Get supervisory factor in percentage"""
        if trade.asset_class == AssetClass.INTEREST_RATE:
            maturity = trade.time_to_maturity()
            if maturity < 2: return 0.5
            elif maturity <= 5: return 0.5
            else: return 1.5
        elif trade.asset_class == AssetClass.FOREIGN_EXCHANGE:
            return 4.0
        elif trade.asset_class == AssetClass.CREDIT:
            return 0.46
        elif trade.asset_class == AssetClass.EQUITY:
            return 32.0
        elif trade.asset_class == AssetClass.COMMODITY:
            return 18.0
        return 1.0

    def _generate_margining_statistics(self, netting_set: NettingSet, collateral: List[Collateral]) -> Dict:
        """Generate margined vs unmargined statistics"""
        sum_v = sum(trade.mtm_value for trade in netting_set.trades)
        sum_c = sum(c.market_value * (1 - c.haircut_percentage/100) for c in collateral) if collateral else 0
        
        # Calculate both margined and unmargined RC for comparison
        rc_unmargined = max(sum_v - sum_c, 0)
        
        if netting_set.is_margined and netting_set.threshold is not None and netting_set.mta is not None:
            rc_margined = max(sum_v - sum_c, netting_set.threshold + netting_set.mta - netting_set.nica, 0)
        else:
            rc_margined = None
        
        return {
            'is_margined': netting_set.is_margined,
            'unmargined_rc': rc_unmargined,
            'margined_rc': rc_margined,
            'sum_v': sum_v,
            'sum_c': sum_c,
            'threshold': netting_set.threshold,
            'mta': netting_set.mta,
            'nica': netting_set.nica
        }

    def _generate_structured_output(self, given_inputs: str, collateral_portfolio: str,
                                    counterparty_details: str, calculation_steps: List[Dict],
                                    final_values: Dict, margining_stats: Dict) -> str:
        """Generate complete structured output in the requested format"""
        
        output = given_inputs + "\n\n"
        
        if collateral_portfolio:
            output += collateral_portfolio + "\n\n"
        
        output += counterparty_details + "\n\n"
        
        output += "🔍 **STEP-BY-STEP CALCULATION:**\n\n"
        
        for step in calculation_steps:
            output += f"**Step {step['step']}: {step['title']}**\n"
            output += f"• **Description**: {step['description']}\n"
            output += f"• **Formula**: `{step['formula']}`\n"
            output += f"• **Calculation**: {step['calculation']}\n"
            output += f"• **Result: {step['result']}**\n\n"
        
        # Add margining comparison if applicable
        if margining_stats['margined_rc'] is not None:
            output += "📊 **MARGINED VS UNMARGINED COMPARISON:**\n"
            output += f"• **Unmargined RC**: ${margining_stats['unmargined_rc']:,.0f}\n"
            output += f"• **Margined RC**: ${margining_stats['margined_rc']:,.0f}\n"
            benefit = margining_stats['unmargined_rc'] - margining_stats['margined_rc']
            output += f"• **Margining Benefit**: ${benefit:,.0f}\n\n"
        
        output += f"✅ **FINAL RESULT: RWA = ${final_values['risk_weighted_assets']:,.0f}**\n"
        output += f"💰 **Capital Requirement = ${final_values['capital_requirement']:,.0f}**"
        
        return output

# ==============================================================================
# STREAMLIT APPLICATION
# ==============================================================================

def main():
    """Main function to run the enhanced Streamlit app."""
    st.markdown("""
    <div class="structured-header">
        <h1>🧮 Enhanced SA-CCR Platform</h1>
        <p>Complete Basel SA-CCR Calculator with Structured Bullet-Point Output</p>
    </div>
    """, unsafe_allow_html=True)
    
    if 'enhanced_agent' not in st.session_state:
        st.session_state.enhanced_agent = EnhancedSACCRAgent()
    
    with st.sidebar:
        st.markdown("### 🔧 Configuration")
        with st.expander("🤖 LLM Setup", expanded=False):
            base_url = st.text_input("Base URL", value="http://localhost:8123/v1")
            api_key = st.text_input("API Key", value="not-needed", type="password")
            model = st.text_input("Model", value="llama3")
            
            if st.button("🔗 Connect LLM"):
                config = {
                    'base_url': base_url, 'api_key': api_key,
                    'model': model, 'temperature': 0.3,
                    'max_tokens': 4000, 'streaming': False
                }
                with st.spinner("Connecting..."):
                    success = st.session_state.enhanced_agent.setup_llm_connection(config)
                    if success:
                        st.success("✅ Connected!")
                    else:
                        st.error("❌ Failed")
        
        st.markdown("---")
        page = st.selectbox("Select Module:", [
            "🧮 SA-CCR Calculator",
            "🤖 AI Assistant",
            "📋 Load Example",
            "📊 Results Viewer"
        ])
    
    if page == "🧮 SA-CCR Calculator":
        saccr_calculator()
    elif page == "🤖 AI Assistant":
        ai_assistant_page()
    elif page == "📋 Load Example":
        load_example()
    elif page == "📊 Results Viewer":
        results_viewer()

def ai_assistant_page():
    """AI assistant for SA-CCR questions and intelligent portfolio analysis"""
    st.markdown('<div class="section-header">🤖 AI SA-CCR Expert Assistant</div>', unsafe_allow_html=True)
    
    # Connection status display
    status = st.session_state.enhanced_agent.connection_status
    if status == "connected":
        st.success("🟢 **AI Assistant Connected** - Describe your trades and I'll calculate RWA!")
    else:
        st.warning("🟡 **AI Assistant Offline** - Connect LLM in sidebar for full AI functionality")
    
    # Initialize session states
    if 'extracted_info' not in st.session_state:
        st.session_state.extracted_info = {}
    if 'ai_chat_history' not in st.session_state:
        st.session_state.ai_chat_history = [
            {
                "role": "assistant", 
                "content": "Hello! I'm your SA-CCR expert assistant. **Just describe your derivatives portfolio or trades**, and I'll ask follow-up questions to calculate your RWA accurately. Try: *'I have a $100M swap with Deutsche Bank'*"
            }
        ]
    
    # Sample usage guide
    with st.expander("💡 How to Use - Just Describe Your Trades", expanded=True):
        col1, col2 = st.columns(2)
        with col1:
            st.markdown("""
            **Examples of what you can say:**
            • "I have a $100M interest rate swap with Bank ABC"
            • "Calculate RWA for 3 FX forwards, total $50M"
            • "My portfolio has margined swaps with 1M threshold"
            • "Need SA-CCR capital for commodity derivatives"
            """)
        
        with col2:
            st.markdown("""
            **I'll automatically:**
            • Extract trade information from your description
            • Ask for missing critical details
            • Make reasonable assumptions where needed
            • Generate complete structured RWA calculation
            """)
    
    # Information collection status
    if st.session_state.extracted_info:
        with st.expander("📋 Information I've Collected", expanded=True):
            for key, value in st.session_state.extracted_info.items():
                formatted_key = key.replace('_', ' ').title()
                if hasattr(value, 'value'):  # Enum
                    formatted_value = value.value
                elif key == 'notional':
                    formatted_value = f"${value:,.0f}"
                else:
                    formatted_value = str(value)
                st.write(f"• {formatted_key}: {formatted_value}")
    
    # Chat interface
    st.markdown("### 💬 Chat Interface")
    
    # Display chat history
    for message in st.session_state.ai_chat_history:
        with st.chat_message(message["role"]):
            st.markdown(message["content"])

    # Chat input
    if prompt := st.chat_input("Describe your trades or ask SA-CCR questions..."):
        # Add user message
        st.session_state.ai_chat_history.append({"role": "user", "content": prompt})
        
        with st.chat_message("user"):
            st.markdown(prompt)

        # Generate response
        with st.chat_message("assistant"):
            with st.spinner("Analyzing your input..."):
                ai_response = process_user_input(prompt)
                st.markdown(ai_response)
        
        st.session_state.ai_chat_history.append({"role": "assistant", "content": ai_response})
    
    # Quick actions
    st.markdown("---")
    col1, col2, col3, col4, col5 = st.columns(5)
    
    with col1:
        if st.button("📚 SA-CCR Basics"):
            response = get_saccr_basics_explanation()
            st.session_state.ai_chat_history.append({"role": "assistant", "content": response})
            st.rerun()
    
    with col2:
        if st.button("🔧 Optimization"):
            response = get_optimization_tips()
            st.session_state.ai_chat_history.append({"role": "assistant", "content": response})
            st.rerun()

    with col3:
        if st.button("📈 Risk Drivers"):
            response = get_risk_drivers_explanation()
            st.session_state.ai_chat_history.append({"role": "assistant", "content": response})
            st.rerun()
    
    with col4:
        if st.button("📊 Calculate RWA"):
            if st.session_state.extracted_info:
                response = generate_rwa_calculation_with_assumptions()
            else:
                response = "Please describe your trades first, then I can calculate RWA."
            st.session_state.ai_chat_history.append({"role": "assistant", "content": response})
            st.rerun()
    
    with col5:
        if st.button("🧹 Clear"):
            st.session_state.extracted_info = {}
            st.session_state.ai_chat_history = [
                {"role": "assistant", "content": "Cleared! Ready for new SA-CCR calculation."}
            ]
            st.rerun()

def generate_ai_response(question: str) -> str:
    """Generate AI response using connected LLM"""
    system_prompt = """You are a world-class Basel III SA-CCR regulatory expert with deep knowledge of:
    - Complete 24-step SA-CCR calculation methodology
    - Regulatory requirements and interpretations
    - Risk management optimization strategies
    - Technical implementation details
    - Cross-asset class derivative structures

    Provide clear, accurate, and actionable responses. Use technical terms appropriately but explain complex concepts clearly. Include formulas, examples, or step-by-step guidance when helpful. Structure your responses with headings and bullet points for clarity."""
    
    try:
        response = st.session_state.enhanced_agent.llm.invoke([
            SystemMessage(content=system_prompt),
            HumanMessage(content=question)
        ])
        return response.content
    except Exception as e:
        return f"**AI Response Error**: {str(e)}\n\nPlease check your LLM connection settings in the sidebar."

def generate_template_response(question: str) -> str:
    """Generate template responses when LLM is not available"""
    question_lower = question.lower()
    
    if "pfe multiplier" in question_lower or "multiplier" in question_lower:
        return """
**PFE Multiplier Explanation** *(LLM Offline - Template Response)*

The **PFE Multiplier** recognizes netting benefits in SA-CCR calculations:

**📊 Formula:**
```
Multiplier = min(1, 0.05 + 0.95 × exp((V-C) / (2 × 0.95 × AddOn)))
```

**🔍 Key Points:**
• **Purpose**: Reduces add-on when portfolio is well-netted
• **Range**: Between 0.05 and 1.0
• **Impact**: Lower multiplier = Lower PFE = Lower Capital
• **Drivers**: Net MTM (V-C) relative to gross risk (AddOn)

**💡 Optimization**: Achieve better netting through offsetting positions in the same hedging sets.
        """
    
    elif "replacement cost" in question_lower or " rc " in question_lower:
        return """
**Replacement Cost (RC) Explanation** *(LLM Offline - Template Response)*

**RC** represents current exposure if counterparty defaults today:

**📊 Formulas:**
```
Unmargined: RC = max(V - C, 0)
Margined:   RC = max(V - C, TH + MTA - NICA, 0)
```

**🔍 Components:**
• **V**: Sum of trade MTM values
• **C**: Effective collateral value (after haircuts)  
• **TH**: Threshold amount
• **MTA**: Minimum Transfer Amount
• **NICA**: Net Independent Collateral Amount

**💡 Key Insight**: Margined agreements can significantly reduce RC through regular collateral posting.
        """
    
    elif "optimization" in question_lower or "reduce" in question_lower:
        return get_optimization_tips()
    
    elif "basic" in question_lower or "explain saccr" in question_lower:
        return get_saccr_basics_explanation()
    
    else:
        return f"""
**AI Assistant Offline** *(Template Response)*

I can provide basic information about these SA-CCR topics:
• **"PFE Multiplier"** - How netting benefits work
• **"Replacement Cost"** - Current exposure calculation  
• **"Optimization"** - Capital reduction strategies
• **"SA-CCR Basics"** - Overview of methodology

**🔧 For Full AI Assistance**: Please connect the LLM in the sidebar to get comprehensive, contextual answers to any SA-CCR question.

**Your Question**: "{question}"
        """

def process_user_input(user_input: str) -> str:
    """Intelligently process user input, extract info, and ask for missing details"""
    
    # Extract information from user input
    extracted = extract_trade_information(user_input)
    
    # Update session state with new information
    if extracted:
        st.session_state.extracted_info.update(extracted)
    
    # Check if this looks like a calculation request
    is_calc_request = any(word in user_input.lower() for word in ['calculate', 'rwa', 'capital', 'exposure', 'ead', 'pfe'])
    
    # If we have enough info for calculation, proceed
    if is_calc_request and has_sufficient_info_for_calculation():
        return generate_rwa_calculation_with_assumptions()
    
    # Otherwise, identify what's missing and ask for it
    missing_info = identify_missing_information()
    
    if missing_info and (extracted or is_calc_request):
        return ask_for_missing_information(missing_info)
    
    # If it's a general question, handle normally
    if st.session_state.enhanced_agent.llm and st.session_state.enhanced_agent.connection_status == "connected":
        return generate_ai_response(user_input)
    else:
        return generate_template_response(user_input)

def extract_trade_information(text: str) -> dict:
    """Extract trade and portfolio information from natural language input"""
    extracted = {}
    text_lower = text.lower()
    
    # Extract notional amounts
    notional_patterns = [
        r'\$(\d+(?:\.\d+)?)\s*(?:m|million)',
        r'\$(\d+(?:\.\d+)?)\s*(?:b|billion)',
        r'\$(\d+(?:,\d{3})*(?:\.\d+)?)',
        r'(\d+(?:\.\d+)?)\s*(?:million|m)\s*(?:dollars?|\$)',
        r'(\d+(?:\.\d+)?)\s*(?:billion|b)\s*(?:dollars?|\$)'
    ]
    
    for pattern in notional_patterns:
        match = re.search(pattern, text_lower)
        if match:
            amount = float(match.group(1).replace(',', ''))
            if 'million' in text_lower or 'm' in text_lower:
                extracted['notional'] = amount * 1_000_000
            elif 'billion' in text_lower or 'b' in text_lower:
                extracted['notional'] = amount * 1_000_000_000
            else:
                extracted['notional'] = amount
            break
    
    # Extract asset classes
    asset_mapping = {
        'interest rate': AssetClass.INTEREST_RATE,
        'swap': AssetClass.INTEREST_RATE,
        'irs': AssetClass.INTEREST_RATE,
        'fx': AssetClass.FOREIGN_EXCHANGE,
        'foreign exchange': AssetClass.FOREIGN_EXCHANGE,
        'forward': AssetClass.FOREIGN_EXCHANGE,  # Often FX
        'credit': AssetClass.CREDIT,
        'cds': AssetClass.CREDIT,
        'equity': AssetClass.EQUITY,
        'commodity': AssetClass.COMMODITY,
        'rates': AssetClass.INTEREST_RATE
    }
    
    for keyword, asset_class in asset_mapping.items():
        if keyword in text_lower:
            extracted['asset_class'] = asset_class
            break
    
    # Extract counterparty information
    bank_indicators = ['bank', 'corp', 'inc', 'ltd', 'llc', 'company', 'financial']
    words = text.split()
    for i, word in enumerate(words):
        if any(indicator in word.lower() for indicator in bank_indicators):
            if i > 0:  # Look for name before bank indicator
                potential_name = ' '.join(words[max(0, i-2):i+1])
                extracted['counterparty'] = potential_name.title()
            break
    
    # Extract maturity
    maturity_patterns = [
        r'(\d+)\s*(?:years?|y)',
        r'(\d+)\s*(?:months?|m)',
        r'maturity[:\s]+(\d+)\s*(?:years?|months?)',
        r'maturing[:\s]+(\d+)\s*(?:years?|months?)'
    ]
    
    for pattern in maturity_patterns:
        match = re.search(pattern, text_lower)
        if match:
            value = int(match.group(1))
            if 'month' in match.group(0):
                extracted['maturity_years'] = value / 12
            else:
                extracted['maturity_years'] = value
            break
    
    # Extract margining status
    if any(word in text_lower for word in ['margined', 'margin', 'threshold', 'mta', 'csa']):
        extracted['is_margined'] = True
        
        # Extract threshold if mentioned
        threshold_match = re.search(r'threshold of \$?(\d+(?:\.\d+)?)\s*(?:m|million|k|thousand)?', text_lower)
        if threshold_match:
            threshold = float(threshold_match.group(1).replace(',', ''))
            if 'million' in threshold_match.group(0) or 'm' in threshold_match.group(0):
                threshold *= 1_000_000
            elif 'thousand' in threshold_match.group(0) or 'k' in threshold_match.group(0):
                threshold *= 1_000
            extracted['threshold'] = threshold
    elif any(word in text_lower for word in ['unmargined', 'no margin', 'no threshold']):
        extracted['is_margined'] = False
    
    # Extract number of trades
    trade_count_patterns = [
        r'(\d+)\s*trades?',
        r'(\d+)\s*transactions?',
        r'(\d+)\s*deals?'
    ]
    
    for pattern in trade_count_patterns:
        match = re.search(pattern, text_lower)
        if match:
            extracted['trade_count'] = int(match.group(1))
            break
    
    # Extract currencies
    currency_patterns = ['usd', 'eur', 'gbp', 'jpy', 'chf', 'cad', 'aud']
    for currency in currency_patterns:
        if currency in text_lower:
            extracted['currency'] = currency.upper()
            break
    
    return extracted

def identify_missing_information() -> list:
    """Identify what information is still needed for accurate RWA calculation"""
    missing = []
    info = st.session_state.extracted_info
    
    # Essential trade information
    if 'notional' not in info:
        missing.append({
            'category': 'Trade Details',
            'field': 'notional',
            'question': "What's the notional amount of your trade(s)? (e.g., $10 million, $100M)"
        })
    
    if 'asset_class' not in info:
        missing.append({
            'category': 'Trade Details', 
            'field': 'asset_class',
            'question': "What type of derivative is this? (Interest Rate Swap, FX Forward, Credit Default Swap, etc.)"
        })
    
    if 'counterparty' not in info:
        missing.append({
            'category': 'Counterparty',
            'field': 'counterparty',
            'question': "Who is your counterparty? (Bank name, corporation, etc.)"
        })
    
    if 'maturity_years' not in info:
        missing.append({
            'category': 'Trade Details',
            'field': 'maturity_years', 
            'question': "What's the maturity/tenor? (e.g., 2 years, 5Y, 18 months)"
        })
    
    # Counterparty details for risk weight
    if 'counterparty' in info and 'counterparty_type' not in info:
        missing.append({
            'category': 'Risk Weight',
            'field': 'counterparty_type',
            'question': f"What type of entity is {info.get('counterparty', 'your counterparty')}? (Bank, Corporation, Sovereign, Other Financial Institution)"
        })
    
    # Margining information
    if 'is_margined' not in info:
        missing.append({
            'category': 'Margining',
            'field': 'is_margined',
            'question': "Are these trades margined (with collateral agreements/CSA) or unmargined?"
        })
    elif info.get('is_margined') and 'threshold' not in info:
        missing.append({
            'category': 'Margining',
            'field': 'threshold',
            'question': "What's the threshold amount in your margin agreement? (e.g., $1M, $500K)"
        })
    
    return missing[:3]  # Limit to 3 questions at a time to avoid overwhelming

def has_sufficient_info_for_calculation() -> bool:
    """Check if we have enough information to perform a reasonable RWA calculation"""
    info = st.session_state.extracted_info
    required_fields = ['notional', 'asset_class']
    return all(field in info for field in required_fields)

def ask_for_missing_information(missing_info: list) -> str:
    """Generate follow-up questions for missing information"""
    if not missing_info:
        return "I have all the information I need. Would you like me to calculate the RWA now?"
    
    response = "I can help you calculate the SA-CCR RWA! I just need a few more details:\n\n"
    
    for i, item in enumerate(missing_info, 1):
        response += f"**{i}. {item['question']}**\n"
    
    response += f"\nYou can answer all at once or one at a time. Based on what you've told me so far:"
    
    # Show what we know
    info = st.session_state.extracted_info
    if info:
        response += "\n\n**Information I have:**"
        for key, value in info.items():
            formatted_key = key.replace('_', ' ').title()
            if isinstance(value, AssetClass):
                formatted_value = value.value
            elif key == 'notional':
                formatted_value = f"${value:,.0f}"
            elif key == 'threshold':
                formatted_value = f"${value:,.0f}"
            else:
                formatted_value = str(value)
            response += f"\n• {formatted_key}: {formatted_value}"
    
    return response

def generate_rwa_calculation_with_assumptions() -> str:
    """Generate RWA calculation using available info and reasonable assumptions"""
    info = st.session_state.extracted_info
    assumptions = make_reasonable_assumptions(info)
    
    # Create objects for calculation
    counterparty_info = CounterpartyInfo(
        name=info.get('counterparty', 'Generic Counterparty'),
        country=assumptions.get('country', 'US'),
        legal_code=assumptions.get('legal_code', 'LEI123456789'),
        legal_code_description=assumptions.get('legal_desc', 'Corporate Entity'),
        counterparty_type=assumptions.get('counterparty_type', CounterpartyType.CORPORATE)
    )
    
    # Create trade
    trade = Trade(
        trade_id="AI-001",
        counterparty=counterparty_info.name,
        asset_class=info.get('asset_class', AssetClass.INTEREST_RATE),
        trade_type=TradeType.SWAP,
        notional=info.get('notional', 10_000_000),
        currency=info.get('currency', 'USD'),
        underlying="Generic",
        maturity_date=datetime.now() + timedelta(days=int(info.get('maturity_years', 5) * 365)),
        mtm_value=0  # Assume at-market
    )
    
    # Create netting set
    netting_set = NettingSet(
        netting_set_id="AI-NS-001",
        counterparty_info=counterparty_info,
        trades=[trade],
        threshold=info.get('threshold') if info.get('is_margined') else None,
        mta=assumptions.get('mta') if info.get('is_margined') else None,
        nica=0.0,
        is_margined=info.get('is_margined', False)
    )
    
    # Perform calculation
    result = st.session_state.enhanced_agent.calculate_structured_saccr(netting_set, [])
    
    if result.get('validation_failed'):
        return "Error in calculation setup. Please provide more complete information."
    
    # Build response
    response = "## 📊 SA-CCR RWA Calculation Based on Your Information\n\n"
    
    # Show assumptions made
    if assumptions:
        response += "**🔍 Assumptions Made:**\n"
        for key, value in assumptions.items():
            formatted_key = key.replace('_', ' ').title()
            if hasattr(value, 'value'):
                 response += f"• {formatted_key}: {value.value}\n"
            else:
                 response += f"• {formatted_key}: {value}\n"
        response += "\n*Please confirm if these assumptions are correct, or provide the actual values.*\n\n"
    
    # Show structured output
    response += result['structured_output']
    
    # Add optimization suggestions
    response += f"\n\n**💡 Optimization Opportunities:**\n"
    rwa = result['final_results']['risk_weighted_assets']
    if info.get('is_margined', False):
        response += f"• Your margined structure helps reduce capital requirements\n"
    else:
        response += f"• Consider margin agreements - could reduce RWA significantly\n"
    
    if rwa > 50_000_000:  # High RWA
        response += f"• Consider trade compression to reduce gross notional\n"
        response += f"• Explore central clearing opportunities\n"
    
    response += f"\n**Would you like me to:**\n"
    response += f"• Adjust any of the assumptions I made?\n"
    response += f"• Add more trades to this calculation?\n" 
    response += f"• Show optimization scenarios?\n"
    
    return response

def make_reasonable_assumptions(info: dict) -> dict:
    """Make reasonable assumptions for missing information"""
    assumptions = {}
    
    # Counterparty type assumptions
    if 'counterparty_type' not in info:
        cp_name = info.get('counterparty', '').lower()
        if 'bank' in cp_name:
            assumptions['counterparty_type'] = CounterpartyType.BANK
        else:
            assumptions['counterparty_type'] = CounterpartyType.CORPORATE
    
    # Country assumption
    if 'counterparty_country' not in info:
        assumptions['country'] = 'US'  # Conservative assumption
    
    # Legal code
    if 'counterparty' in info:
        assumptions['legal_code'] = f"LEI{info['counterparty'].replace(' ', '').upper()[:10]}"
        assumptions['legal_desc'] = f"{info['counterparty']} - Corporate Entity"
    
    # MTA assumption for margined trades
    if info.get('is_margined') and 'mta' not in info:
        threshold = info.get('threshold', 1_000_000)
        assumptions['mta'] = min(250_000, threshold * 0.25)  # 25% of threshold or $250K
    
    # Currency assumption
    if 'currency' not in info:
        assumptions['currency'] = 'USD'
    
    return assumptions

def get_saccr_basics_explanation() -> str:
    """Get basic SA-CCR explanation"""
    return """
**📚 SA-CCR Basics Overview**

**What is SA-CCR?**
The **Standardised Approach for Counterparty Credit Risk** is Basel III's method for calculating capital requirements for derivative exposures.

**🎯 Core Formula:**
```
RWA = Risk Weight × EAD
EAD = α × (RC + PFE)
```

**🏗️ Key Components:**

**1. Replacement Cost (RC)**
• Current cost to replace trades if counterparty defaults
• Benefits from netting and collateral

**2. Potential Future Exposure (PFE)** • Future risk from market movements
• Calculated using supervisory factors and add-ons

**3. Exposure at Default (EAD)**
• Total exposure combining current and future risk
• Uses regulatory alpha factor (α = 1.4)

**📊 The Process:**
1. **Group** trades into netting sets and hedging sets
2. **Calculate** add-ons using supervisory parameters  
3. **Apply** multiplier for netting benefits
4. **Combine** with replacement cost
5. **Apply** risk weights based on counterparty type

**💡 Key Benefits:**
• More risk-sensitive than previous approaches
• Recognizes diversification and netting
• Consistent global implementation
    """

def get_optimization_tips() -> str:
    """Get SA-CCR optimization strategies"""
    return """
**🔧 SA-CCR Capital Optimization Strategies**

**1. 📊 Portfolio Netting**
• **Strategy**: Execute offsetting trades within same netting sets
• **Impact**: Improves PFE multiplier, reduces aggregate add-on
• **Example**: Long and short positions in same currency/tenor

**2. 🛡️ Collateral Management**
• **Strategy**: Post high-quality, low-haircut collateral
• **Impact**: Reduces replacement cost (RC)
• **Best Collateral**: Cash (0% haircut) > Govt bonds (0.5%) > Corporate bonds (4%)

**3. 🏛️ Central Clearing**
• **Strategy**: Clear eligible trades through CCPs
• **Impact**: Lower risk weights, standardized margining
• **Benefit**: Typically 2-4% risk weight vs 20-100% bilateral

**4. ⚖️ Margin Agreements**
• **Strategy**: Implement comprehensive CSAs with low thresholds
• **Impact**: Can dramatically reduce RC
• **Key Terms**: Lower threshold + MTA = Better capital efficiency

**5. 🎯 Trade Compression**
• **Strategy**: Eliminate redundant trades while maintaining risk profile
• **Impact**: Reduces gross notional, lowers add-ons
• **Process**: Regular portfolio optimization cycles

**6. 📅 Maturity Management**
• **Strategy**: Optimize trade tenors within hedging sets
• **Impact**: Maturity factors affect supervisory add-ons
• **Sweet Spot**: Often around 1-year maturity for factor optimization

**💡 Pro Tip**: Combine multiple strategies for maximum impact - a well-collateralized, netted, centrally-cleared portfolio can achieve 80%+ capital savings vs worst-case scenarios.
    """

def get_risk_drivers_explanation() -> str:
    """Get risk drivers explanation"""
    return """
**📊 Key SA-CCR Risk Drivers**

**1. 🎯 Notional Amounts**
• **Impact**: Direct input to add-on calculations
• **Insight**: Gross notional matters more than net notional
• **Management**: Trade compression to reduce gross exposure

**2. 🏷️ Asset Class Mix**
• **Impact**: Different supervisory factors by asset class
• **Hierarchy (Highest to Lowest SF)**: Equity (32%) > Commodity (18%) > FX (4%) > Rates (0.5-1.5%) > Credit (0.46%)
• **Strategy**: Understand your portfolio composition

**3. ⏰ Maturity Profile** • **Impact**: Maturity factors affect add-on magnitude
• **Formula**: MF = √(min(M,1)) where M = years to maturity
• **Optimization**: Shorter maturities (under 1 year) generally more capital efficient

**4. 🔄 Netting Efficiency**
• **Impact**: Better netting improves PFE multiplier
• **Measurement**: Net MTM vs Gross Add-on ratio
• **Target**: Achieve multiplier closer to 0.05 minimum

**5. 🏦 Counterparty Type**
• **Impact**: Risk weights vary dramatically
• **Range**: Sovereigns (0%) < Banks (20%) < Corporates (100%) < Others (125%)
• **Strategy**: Counterparty diversification considerations

**6. 💰 Collateral Quality & Coverage**
• **Impact**: Directly reduces replacement cost
• **Quality Ladder**: Cash > Govt Bonds > IG Corporates > Equities
• **Coverage**: Over-collateralization can zero out RC

**7. 🎛️ Margin Agreement Terms**
• **Impact**: Threshold + MTA determines margined RC floor
• **Optimization**: Lower thresholds and MTAs reduce capital
• **Trade-off**: Operational burden vs capital efficiency

**📈 Monitoring Dashboard KPIs:**
• Aggregate Add-on by Asset Class
• PFE Multiplier Trends  
• Net vs Gross Exposure Ratios
• Collateral Utilization Rates
• Average Risk Weight by Counterparty
    """

def saccr_calculator():
    """Enhanced SA-CCR calculator with structured output"""
    st.markdown('<div class="section-header">📊 SA-CCR Calculation Setup</div>', unsafe_allow_html=True)
    
    # Netting Set Information
    with st.expander("📋 Netting Set Information", expanded=True):
        col1, col2 = st.columns(2)
        with col1:
            netting_set_id = st.text_input("Netting Set ID*", placeholder="NS-001")
        with col2:
            is_margined = st.checkbox("Margined Netting Set", help="Check if this netting set has margin agreements")
    
    # Counterparty Information
    with st.expander("🏢 Counterparty Information", expanded=True):
        col1, col2, col3 = st.columns(3)
        with col1:
            cp_name = st.text_input("Counterparty Name*", placeholder="Example Corp")
            cp_country = st.selectbox("Country*", ["", "US", "GB", "DE", "JP", "CA", "AU", "CH", "Other"])
        with col2:
            cp_legal_code = st.text_input("Legal Entity Code*", placeholder="LEI123456789")
            cp_type = st.selectbox("Counterparty Type*", [ct.value for ct in CounterpartyType])
        with col3:
            cp_legal_desc = st.text_input("Legal Code Description*", placeholder="Corporate Entity")
            cp_rating = st.text_input("Credit Rating", placeholder="BBB+ (Optional)")
    
    # Margining Details
    if is_margined:
        with st.expander("💰 Margining Agreement Details", expanded=True):
            col1, col2, col3 = st.columns(3)
            with col1:
                threshold = st.number_input("Threshold ($)*", min_value=0.0, value=1000000.0)
            with col2:
                mta = st.number_input("MTA ($)*", min_value=0.0, value=250000.0)
            with col3:
                nica = st.number_input("NICA ($)", min_value=0.0, value=0.0)
    else:
        threshold = None
        mta = None
        nica = 0.0
    
    # Trade Input
    st.markdown('<div class="section-header">📈 Trade Portfolio</div>', unsafe_allow_html=True)
    
    if 'enhanced_trades' not in st.session_state:
        st.session_state.enhanced_trades = []
    
    with st.form("enhanced_trade_form"):
        col1, col2, col3, col4 = st.columns(4)
        with col1:
            trade_id = st.text_input("Trade ID*", placeholder=f"T-{len(st.session_state.enhanced_trades)+1:03d}")
            asset_class = st.selectbox("Asset Class*", [ac.value for ac in AssetClass])
        with col2:
            notional = st.number_input("Notional ($)*", min_value=1.0, value=10000000.0, step=1000000.0)
            currency = st.selectbox("Currency*", ["USD", "EUR", "GBP", "JPY", "CHF", "CAD", "AUD"])
        with col3:
            maturity_years = st.number_input("Maturity (Years)*", min_value=0.1, value=5.0, step=0.5)
            trade_type = st.selectbox("Trade Type", [tt.value for tt in TradeType])
        with col4:
            mtm_value = st.number_input("MTM Value ($)", value=0.0, step=50000.0)
            delta = st.number_input("Delta", min_value=-1.0, max_value=1.0, value=1.0, step=0.1)

        if st.form_submit_button("➕ Add Trade"):
            if trade_id and notional > 0 and cp_name:
                new_trade = Trade(
                    trade_id=trade_id,
                    counterparty=cp_name,
                    asset_class=AssetClass(asset_class),
                    trade_type=TradeType(trade_type),
                    notional=notional,
                    currency=currency,
                    underlying="Generic",
                    maturity_date=datetime.now() + timedelta(days=int(maturity_years * 365)),
                    mtm_value=mtm_value,
                    delta=delta
                )
                st.session_state.enhanced_trades.append(new_trade)
                st.success(f"✅ Added {trade_id}")
            else:
                st.error("❌ Please fill required fields")

    # Display current trades
    if st.session_state.enhanced_trades:
        st.markdown("**Current Trades:**")
        trades_df = pd.DataFrame([{
            'Trade ID': t.trade_id,
            'Asset Class': t.asset_class.value,
            'Notional ($M)': f"{t.notional/1e6:.1f}",
            'Currency': t.currency,
            'MTM ($K)': f"{t.mtm_value/1e3:.0f}",
            'Maturity (Y)': f"{t.time_to_maturity():.1f}"
        } for t in st.session_state.enhanced_trades])
        st.dataframe(trades_df, use_container_width=True)
        
        if st.button("🗑️ Clear All Trades"):
            st.session_state.enhanced_trades = []
            st.rerun()

    # Collateral Input
    st.markdown('<div class="section-header">🛡️ Collateral Portfolio</div>', unsafe_allow_html=True)
    
    if 'enhanced_collateral' not in st.session_state:
        st.session_state.enhanced_collateral = []
    
    with st.form("enhanced_collateral_form"):
        col1, col2, col3 = st.columns(3)
        with col1:
            coll_type = st.selectbox("Collateral Type", [ct.value for ct in CollateralType])
        with col2:
            coll_amount = st.number_input("Market Value ($)", min_value=0.0, value=1000000.0)
        with col3:
            coll_currency = st.selectbox("Currency", ["USD", "EUR", "GBP", "JPY", "CHF"])

        if st.form_submit_button("➕ Add Collateral"):
            new_coll = Collateral(
                collateral_type=CollateralType(coll_type),
                currency=coll_currency,
                amount=coll_amount,
                market_value=coll_amount
            )
            st.session_state.enhanced_collateral.append(new_coll)
            st.success(f"✅ Added {coll_type}")

    # Display current collateral
    if st.session_state.enhanced_collateral:
        st.markdown("**Current Collateral:**")
        for i, coll in enumerate(st.session_state.enhanced_collateral, 1):
            effective_value = coll.market_value * (1 - coll.haircut_percentage/100)
            st.write(f"{i}. {coll.collateral_type.value}: ${coll.market_value:,.0f} (Effective: ${effective_value:,.0f} after {coll.haircut_percentage}% haircut)")

    # Calculate Button
    st.markdown("---")
    if st.button("🚀 Calculate SA-CCR with Structured Output", type="primary", use_container_width=True):
        # Create counterparty info object
        counterparty_info = CounterpartyInfo(
            name=cp_name,
            country=cp_country,
            legal_code=cp_legal_code,
            legal_code_description=cp_legal_desc,
            counterparty_type=CounterpartyType(cp_type),
            credit_rating=cp_rating
        )
        
        # Create netting set
        netting_set = NettingSet(
            netting_set_id=netting_set_id,
            counterparty_info=counterparty_info,
            trades=st.session_state.enhanced_trades,
            threshold=threshold,
            mta=mta,
            nica=nica,
            is_margined=is_margined
        )
        
        with st.spinner("🧮 Performing Enhanced SA-CCR calculation..."):
            try:
                result = st.session_state.enhanced_agent.calculate_structured_saccr(
                    netting_set, 
                    st.session_state.enhanced_collateral
                )
                
                # Store result in session state for viewing
                st.session_state.latest_result = result
                
                display_enhanced_results(result)
                
            except Exception as e:
                st.error(f"❌ Calculation error: {str(e)}")

def display_enhanced_results(result: Dict):
    """Display enhanced structured results"""
    if result.get('validation_failed'):
        st.markdown('<div class="missing-info">', unsafe_allow_html=True)
        st.error("❌ **Missing Required Information**")
        
        st.markdown("**Please provide the following missing information:**")
        for field in result['missing_fields']:
            st.write(f"• {field}")
        
        if result.get('warnings'):
            st.markdown("**Warnings:**")
            for warning in result['warnings']:
                st.warning(warning)
        
        st.markdown('</div>', unsafe_allow_html=True)
        return
    
    # Display structured output
    st.markdown("## 📊 SA-CCR Calculation Results")
    
    # Key metrics summary
    final_results = result['final_results']
    col1, col2, col3, col4, col5 = st.columns(5)
    col1.metric("RWA", f"${final_results['risk_weighted_assets']/1e6:.2f}M")
    col2.metric("Capital Required", f"${final_results['capital_requirement']/1e3:.1f}K")
    col3.metric("EAD", f"${final_results['exposure_at_default']/1e6:.2f}M")
    col4.metric("PFE", f"${final_results['potential_future_exposure']/1e6:.2f}M")
    col5.metric("RC", f"${final_results['replacement_cost']/1e6:.2f}M")
    
    # Display structured output
    st.markdown("### 📋 Complete Structured Calculation")
    st.markdown(result['structured_output'])
    
    # Margining statistics
    if result.get('margining_statistics'):
        stats = result['margining_statistics']
        if stats['margined_rc'] is not None:
            st.markdown("### 📈 Margining Impact Analysis")
            col1, col2, col3 = st.columns(3)
            col1.metric("Unmargined RC", f"${stats['unmargined_rc']:,.0f}")
            col2.metric("Margined RC", f"${stats['margined_rc']:,.0f}")
            benefit = stats['unmargined_rc'] - stats['margined_rc']
            col3.metric("Margining Benefit", f"${benefit:,.0f}", delta=f"${-benefit:,.0f}")

def load_example():
    """Load predefined examples"""
    st.markdown('<div class="section-header">📋 Load Reference Examples</div>', unsafe_allow_html=True)
    
    example_type = st.selectbox("Select Example Type:", [
        "Corporate Interest Rate Swap Portfolio",
        "Bank FX Forward Portfolio", 
        "Securities Based Lending",
        "Multi-Asset Margined Portfolio"
    ])
    
    if st.button("🔄 Load Selected Example", type="primary"):
        if example_type == "Corporate Interest Rate Swap Portfolio":
            load_corporate_example()
        elif example_type == "Bank FX Forward Portfolio":
            load_bank_example()
        elif example_type == "Securities Based Lending":
            load_sbl_example()
        elif example_type == "Multi-Asset Margined Portfolio":
            load_margined_example()
        
        st.success(f"✅ Loaded {example_type} example!")
        st.info("Navigate to the 'SA-CCR Calculator' page to view and run the example.")

def load_corporate_example():
    """Load corporate IRS portfolio example"""
    # Clear existing data
    st.session_state.enhanced_trades = [
        Trade(
            trade_id="IRS-001",
            counterparty="Corporate ABC",
            asset_class=AssetClass.INTEREST_RATE,
            trade_type=TradeType.SWAP,
            notional=100_000_000,
            currency="USD",
            underlying="USD-LIBOR-3M",
            maturity_date=datetime.now() + timedelta(days=365*5),
            mtm_value=1_500_000,
            delta=1.0
        ),
        Trade(
            trade_id="IRS-002", 
            counterparty="Corporate ABC",
            asset_class=AssetClass.INTEREST_RATE,
            trade_type=TradeType.SWAP,
            notional=-75_000_000,
            currency="USD",
            underlying="USD-LIBOR-3M",
            maturity_date=datetime.now() + timedelta(days=365*10),
            mtm_value=-900_000,
            delta=-1.0
        )
    ]
    
    st.session_state.enhanced_collateral = [
        Collateral(
            collateral_type=CollateralType.CASH,
            currency="USD",
            amount=500_000,
            market_value=500_000
        )
    ]

def load_sbl_example():
    """Load securities-based lending example similar to the provided sample"""
    st.session_state.enhanced_trades = [
        Trade(
            trade_id="SBL-001",
            counterparty="GWIM Client",
            asset_class=AssetClass.CREDIT, # SBL is treated as a credit derivative
            trade_type=TradeType.FORWARD,
            notional=1_000_000,
            currency="USD", 
            underlying="Securities Based Loan",
            maturity_date=datetime.now() + timedelta(days=90), # Assuming a 90-day renewable term
            mtm_value=1_000_000,  # Funded amount
            delta=1.0
        )
    ]
    
    # Recreate the collateral from the example
    st.session_state.enhanced_collateral = [
        Collateral(collateral_type=CollateralType.CASH, currency="USD", amount=150_000, market_value=150_000),
        Collateral(collateral_type=CollateralType.GOVERNMENT_BONDS, currency="USD", amount=450_000, market_value=450_000),
        Collateral(collateral_type=CollateralType.MONEY_MARKET, currency="USD", amount=300_000, market_value=300_000),
        Collateral(collateral_type=CollateralType.EQUITIES, currency="USD", amount=1_500_000, market_value=1_500_000)
    ]

def load_bank_example():
    """Load bank FX portfolio example"""
    st.session_state.enhanced_trades = [
        Trade(
            trade_id="FX-001",
            counterparty="Global Bank",
            asset_class=AssetClass.FOREIGN_EXCHANGE,
            trade_type=TradeType.FORWARD,
            notional=50_000_000,
            currency="EUR",
            underlying="EUR/USD",
            maturity_date=datetime.now() + timedelta(days=180),
            mtm_value=250_000,
            delta=1.0
        ),
        Trade(
            trade_id="FX-002",
            counterparty="Global Bank", 
            asset_class=AssetClass.FOREIGN_EXCHANGE,
            trade_type=TradeType.FORWARD,
            notional=-50_000_000,
            currency="EUR",
            underlying="EUR/USD",
            maturity_date=datetime.now() + timedelta(days=90),
            mtm_value=-150_000,
            delta=-1.0
        )
    ]
    
    st.session_state.enhanced_collateral = []

def load_margined_example():
    """Load complex margined portfolio example"""
    st.session_state.enhanced_trades = [
        Trade(
            trade_id="SWAP-001",
            counterparty="Investment Bank",
            asset_class=AssetClass.INTEREST_RATE,
            trade_type=TradeType.SWAP,
            notional=200_000_000,
            currency="USD",
            underlying="USD-SOFR",
            maturity_date=datetime.now() + timedelta(days=365*7),
            mtm_value=3_200_000,
            delta=1.0
        ),
        Trade(
            trade_id="FX-001",
            counterparty="Investment Bank",
            asset_class=AssetClass.FOREIGN_EXCHANGE,
            trade_type=TradeType.FORWARD,
            notional=100_000_000,
            currency="EUR",
            underlying="EUR/USD",
            maturity_date=datetime.now() + timedelta(days=365),
            mtm_value=-800_000,
            delta=1.0
        )
    ]
    
    st.session_state.enhanced_collateral = [
        Collateral(collateral_type=CollateralType.CASH, currency="USD", amount=2_000_000, market_value=2_000_000),
        Collateral(collateral_type=CollateralType.GOVERNMENT_BONDS, currency="USD", amount=1_000_000, market_value=1_000_000)
    ]

def results_viewer():
    """View and export calculation results"""
    st.markdown('<div class="section-header">📊 Results Viewer & Export</div>', unsafe_allow_html=True)
    
    if 'latest_result' not in st.session_state or not st.session_state.latest_result:
        st.info("📝 No calculation results available. Please run a calculation first.")
        return
    
    result = st.session_state.latest_result
    
    if result.get('validation_failed'):
        st.warning("⚠️ Last calculation failed validation. Please complete the required inputs.")
        return
    
    # Display results
    st.markdown("### 📋 Latest Calculation Results")
    display_enhanced_results(result)
    
    # Export options
    st.markdown("### 📤 Export Options")
    col1, col2 = st.columns(2)
    
    with col1:
        # The copy-to-clipboard functionality in Streamlit is complex to implement
        # robustly without external libraries, so we'll show the text for manual copying.
        with st.expander("📋 Copy Results Text"):
            st.code(result['structured_output'], language="markdown")

    with col2:
        # Prepare download data
        download_data = result['structured_output']
        st.download_button(
            label="💾 Download as Text File",
            data=download_data,
            file_name="saccr_calculation_results.txt",
            mime="text/plain"
        )

if __name__ == "__main__":
    main()
